# async-nonblocking-call
异步非阻塞调用示例

# 同步调用、异步阻塞、异步非阻塞的特点

1. 同步： 
	客户端发起调用，线程处于运行状态，同步等待服务端返回结果。期间客户端线程一直占用cpu资源，并且没有机会执行调用后代码。
2. 异步：
	客户端发起调用，服务端立即返回，结果在未来某个时刻通知给客户端。客户端如果不关注调用结果，可以直接退出，也可以执行调用后的代码逻辑。如果客户端需要关注结果，可以选择阻塞当前线程，或者非阻塞的方式来获取结果。
3. 异步阻塞：
	客户端需要获得调用结果，并且希望在获得结果前不执行后面的代码逻辑。此时，可以将调用线程挂起，进入阻塞状态，等待服务端通知返回结果时，再唤醒调用线程。在等待结果返回期间，客户端线程不占用cpu资源，保持代码执行顺序。
4. 异步非阻塞：
	客户端关心调用结果，且这个结果不影响后续代码逻辑，只需要在返回结果时做入库记录等操作。如此，客户端发起调用后，不必阻塞当前线程，只需添加监听器（监听器在调用结果被通知时触发，执行记录操作等），然后执行后面的代码逻辑，或者退出。在发起调用到获取结果期间，客户端线程不因为本次调用占用线程资源，且不阻塞线程。但需要一个其他线程来执行结果监听器，实际应用中，可以使用客户端的线程池来执行。
